#!/usr/bin/env bash
#
# ==================================================================
# Sourced Utility Script
# Provides strict mode, error trapping, and colorized logging functions.
# ==================================================================

# --- Strict Mode & Error Handling ---
# -e: exit immediately if a command exits with a non-zero status.
# -u: treat unset variables as an error when substituting.
# -o pipefail: the return value of a pipeline is the status of the last command
#              to exit with a non-zero status, or zero if no command exited with a non-zero status.
set -euo pipefail

# Trap errors and print a helpful message before exiting.
trap 's=$?; echo >&2 "[$0] Error on line $LINENO: $BASH_COMMAND"; exit $s' ERR

# --- Formatting and Colors ---
# Use tput for portability; fallback to empty strings if tput is not available or terminal is not supported.
if command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1; then
  readonly GREEN=$(tput setaf 2)
  readonly RED=$(tput setaf 1)
  readonly YELLOW=$(tput setaf 3)
  readonly BLUE=$(tput setaf 4)
  readonly NC=$(tput sgr0) # No Color
else
  readonly GREEN=""
  readonly RED=""
  readonly YELLOW=""
  readonly BLUE=""
  readonly NC=""
fi

# --- Logging Functions ---
# Prefixes messages with color-coded tags for clarity.

log_info() {
  printf "${BLUE}[INFO]${NC} %s\n" "$*"
}

log_success() {
  printf "${GREEN}[SUCCESS]${NC} %s\n" "$*"
}

log_warn() {
  printf "${YELLOW}[WARN]${NC} %s\n" "$*"
}

log_error() {
  # Errors are sent to stderr. The script will exit due to `set -e` and the ERR trap.
  printf "${RED}[ERROR]${NC} %s\n" "$*" >&2
}

# filename of currently running script
TOOL_NAME=$(basename "$0")

########
### Various universal functions, mostly for a nice console output:

# Prints an exit status message when called (probably often through trap or in main function)
# Arguments:
#   $1: Exit code (optional, defaults to 0 if not provided)
exit_tool() {
  local exit_code=${1:-0} # Default to 0 if no argument is provided
  if [ "$exit_code" -eq 0 ]; then
    log_success "Success!"
    exit 0
  else
    log_error "Failed!"
    exit "$exit_code"
  fi
}

# Prints general status messages with visual indicators.
# Arguments:
#   $1: The message to display.
#   $2: The return code indicator ('ok', 'aa', 'ee'). Defaults to 'ee'.
check() {
  local message=${1:-"null"}
  local return_code=${2:-"ee"} # Default to 'ee' (error) if not specified

  case "$return_code" in
  ee)
    printf "%-65s %s\n" "$message " "$EE"
    echo "Failed task: $TOOL_NAME" >&2 # Output to stderr for errors
    return 1
    ;;
  aa)
    printf "%-65s %s\n" "$message " "$AA"
    return 0 # Indicate success for 'aa'
    ;;
  ok)
    printf "%-65s %s\n" "$message " "$OK"
    return 0 # Indicate success for 'ok'
    ;;
  *)
    printf "%-65s %s\n" "$message " "$EE" # Default to error for unknown codes
    echo "Unknown return code '$return_code' used for message: $message" >&2
    return 1
    ;;
  esac
}
